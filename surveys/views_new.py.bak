from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import HttpResponse
from django.forms import modelformset_factory
from django.db import models, transaction
from django.core.exceptions import ValidationError
from django.conf import settings
from django.core.files import File
from django.apps import apps
from django.utils import timezone
from .models import get_questionnaire, get_question, get_question_choice, get_qr_code, get_scoring_config
from .models.email_schedule import EmailTemplate
import logging

logger = logging.getLogger(__name__)

# Get model references with direct database model names for reliability
try:
    Questionnaire = apps.get_model('surveys', 'SurveysQuestionnaire')
    Question = apps.get_model('surveys', 'SurveysQuestion')
    QuestionChoice = apps.get_model('surveys', 'SurveysQuestionchoice')
    QRCode = apps.get_model('surveys', 'SurveysQrcode')
    ScoringConfig = apps.get_model('surveys', 'SurveysScoringconfig')
except Exception:
    # Fallback to getter functions if direct access fails
    Questionnaire = get_questionnaire()
    Question = get_question()
    QuestionChoice = get_question_choice()
    QRCode = get_qr_code()
    ScoringConfig = get_scoring_config()
from .forms import SurveyForm, QuestionForm, QuestionChoiceForm, QRCodeForm, ScoringConfigForm, EmailTemplateForm
from .utils import log_form_errors, log_model_creation_attempt, log_exception
import qrcode
from io import BytesIO
import logging
import traceback
import json

# Set up logger
logger = logging.getLogger(__name__)

@login_required
def country_question_create(request, survey_pk):
    """
    Create a new country question for a survey with minimal input
    """
    try:
        # Get the questionnaire
        questionnaire = get_object_or_404(Questionnaire, pk=survey_pk)

        # Check if user has permission to add questions to this questionnaire
        if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user).exists():
            messages.error(request, "You don't have permission to add questions to this questionnaire.")
            return redirect('surveys:survey_detail', pk=survey_pk)

        # Get the next order number
        next_order = questionnaire.questions.count() + 1

        if request.method == 'POST':
            # Get the question text from the form
            question_text = request.POST.get('text', 'What country are you from?')
            description = request.POST.get('description', '')
            required = request.POST.get('required', 'on') == 'on'

            # Create the question
            question = Question(
                survey=questionnaire,
                text=question_text,
                description=description,
                question_type='country',
                required=required,
                order=next_order,
                created_at=timezone.now(),
                updated_at=timezone.now()
            )

            # Try to get the QuestionType object for 'country'
            try:
                from surveys.models.question_type import QuestionType
                question_type_obj = QuestionType.objects.filter(code='country').first()
                if question_type_obj and hasattr(question, 'question_type_obj'):
                    question.question_type_obj = question_type_obj
            except Exception as e:
                logger.error(f"Error setting question_type_obj: {e}")

            question.save()

            messages.success(request, 'Country question added successfully!')
            return redirect('surveys:question_list', pk=survey_pk)

        # For GET requests, render the country question form
        return render(request, 'surveys/country_question_form.html', {
            'survey': questionnaire,
            'next_order': next_order
        })
    except Exception as e:
        logger.error(f"Error in country_question_create: {e}")
        messages.error(request, f"An error occurred: {e}")
        return redirect('surveys:survey_detail', pk=survey_pk)

@login_required
def survey_list(request):
    """
    Display a list of all questionnaires
    """
    try:
        # Try to get questionnaires created by the user if the field exists
        user_questionnaires = Questionnaire.objects.filter(created_by=request.user)

        # Get questionnaires from organizations the user is a member of
        org_questionnaires = Questionnaire.objects.filter(organization__members__user=request.user)

        # Combine and remove duplicates
        questionnaires = (user_questionnaires | org_questionnaires).distinct()
    except Exception as e:
        # If 'created_by' field doesn't exist, just get questionnaires from organizations
        print(f"Error filtering by created_by: {e}")
        questionnaires = Questionnaire.objects.filter(organization__members__user=request.user)

    # Filter by category if provided
    category = request.GET.get('category')
    if category:
        questionnaires = questionnaires.filter(category=category)

    # Filter by status if provided
    status = request.GET.get('status')
    if status:
        questionnaires = questionnaires.filter(status=status)

    try:
        # Try to get template questionnaires if the field exists
        template_questionnaires = Questionnaire.objects.filter(is_template=True)
    except Exception as e:
        # If 'is_template' field doesn't exist, use an empty queryset
        print(f"Error filtering by is_template: {e}")
        template_questionnaires = Questionnaire.objects.none()

    # Define fallback choices if the model doesn't have them
    try:
        categories = Questionnaire.CATEGORY_CHOICES
    except AttributeError:
        # Fallback categories
        categories = [
            ('anxiety', 'Anxiety'),
            ('depression', 'Depression'),
            ('stress', 'Stress'),
            ('general', 'General'),
            ('mental_health', 'Mental Health'),
            ('physical_health', 'Physical Health'),
            ('education', 'Education'),
            ('customer_satisfaction', 'Customer Satisfaction'),
            ('employee_feedback', 'Employee Feedback'),
            ('research', 'Research'),
            ('clinical_assessment', 'Clinical Assessment'),
            ('custom', 'Custom'),
        ]

    try:
        statuses = Questionnaire.STATUS_CHOICES
    except AttributeError:
        # Fallback statuses
        statuses = [
            ('draft', 'Draft'),
            ('active', 'Active'),
            ('archived', 'Archived'),
            ('inactive', 'Inactive'),
        ]

    context = {
        'questionnaires': questionnaires,
        'template_questionnaires': template_questionnaires,
        'categories': categories,
        'statuses': statuses,
    }

    return render(request, 'surveys/survey_list.html', context)

@login_required
def survey_create(request):
    """
    Create a new questionnaire
    """
    if request.method == 'POST':
        form = SurveyForm(request.POST)
        if form.is_valid():
            try:
                # Create the questionnaire but don't save to DB yet
                questionnaire = form.save(commit=False)

                try:
                    # Try to set the created_by field to the current user if it exists
                    questionnaire.created_by = request.user
                except Exception as e:
                    # If the field doesn't exist, log the error but continue
                    print(f"Warning: Could not set created_by field: {e}")

                # Set default values for fields not in the form
                try:
                    if not questionnaire.type:
                        questionnaire.type = 'standard'
                except Exception as e:
                    # If the field doesn't exist, log the error but continue
                    print(f"Warning: Could not set type field: {e}")

                # Now save to the database
                questionnaire.save()

                # Save many-to-many relationships if any
                form.save_m2m()

                # If cloning from a template
                template_id = request.POST.get('template_id')
                if template_id:
                    try:
                        # Try to get the template questionnaire
                        try:
                            # First try with is_template filter
                            template = get_object_or_404(Questionnaire, pk=template_id, is_template=True)
                        except Exception as e:
                            # If is_template field doesn't exist, just get by ID
                            print(f"Error filtering by is_template: {e}")
                            template = get_object_or_404(Questionnaire, pk=template_id)

                        # Import timezone for datetime fields
                        from django.utils import timezone

                        # Clone questions from template
                        for template_question in template.questions.all():
                            question = Question.objects.create(
                                survey=questionnaire,
                                text=template_question.text,
                                description=template_question.description,
                                question_type=template_question.question_type,
                                required=template_question.required,
                                order=template_question.order,
                                # Add created_at and updated_at fields
                                created_at=timezone.now(),
                                updated_at=timezone.now()
                            )
                            # Clone choices if applicable
                            for template_choice in template_question.choices.all():
                                # Include created_at and updated_at fields to satisfy NOT NULL constraint
                                QuestionChoice.objects.create(
                                    question=question,
                                    text=template_choice.text,
                                    order=template_choice.order,
                                    score=template_choice.score,
                                    created_at=timezone.now(),
                                    updated_at=timezone.now()
                                )
                    except Exception as e:
                        # If there's an error with the template, log it but continue
                        print(f"Error cloning template: {e}")
                        # The questionnaire is still created, just without template questions

                messages.success(request, 'Questionnaire created successfully!')
                return redirect('surveys:survey_detail', pk=questionnaire.pk)

            except Exception as e:
                # If there's an error saving the questionnaire, show it to the user
                print(f"Error creating questionnaire: {e}")
                messages.error(request, f"Error creating questionnaire: {e}")
        else:
            # If the form is not valid, show the errors
            print(f"Form errors: {form.errors}")
    else:
        form = SurveyForm()

    # Get template questionnaires for cloning
    try:
        # Try to get template questionnaires if the field exists
        template_questionnaires = Questionnaire.objects.filter(is_template=True)
    except Exception as e:
        # If 'is_template' field doesn't exist, use an empty queryset
        print(f"Error filtering by is_template: {e}")
        template_questionnaires = Questionnaire.objects.none()

    return render(request, 'surveys/survey_form.html', {
        'form': form,
        'template_questionnaires': template_questionnaires
    })

@login_required
def survey_preview(request, pk):
    """
    Preview a questionnaire with progress bar and navigation
    """
    # Try to get the questionnaire by primary key
    # Handle the case where pk might be a string that's not a valid UUID
    try:
        # First try to convert to int if it's a numeric string
        if pk.isdigit():
            pk = int(pk)
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        # If that fails, try to find by other fields
        try:
            # Try to find by slug
            questionnaire = get_object_or_404(Questionnaire, slug=pk)
        except:
            # If all else fails, show an error
            messages.error(request, f"Could not find questionnaire with ID: {pk}")
            return redirect('surveys:survey_list')

    # Check if this is a preview request
    is_preview = request.GET.get('preview') == 'true'

    try:
        is_creator = request.user == questionnaire.created_by
    except Exception as e:
        print(f"Error checking if user is creator: {e}")
        is_creator = False

    is_admin = request.user.is_staff

    # If it's a preview or the user is the creator/admin, allow access regardless of questionnaire status
    if is_preview or is_creator or is_admin:
        # Allow access for preview mode
        pass
    # Otherwise, check if user has permission to view this questionnaire
    elif questionnaire.created_by != request.user:
        if questionnaire.organization and not questionnaire.organization.members.filter(user=request.user).exists():
            messages.error(request, "You don't have permission to preview this questionnaire.")
            return redirect('surveys:survey_list')
        elif not questionnaire.organization:
            messages.error(request, "You don't have permission to preview this questionnaire.")
            return redirect('surveys:survey_list')

    # Get all questions for this questionnaire
    questions = questionnaire.questions.all().order_by('order')

    # Get the current question index from the query parameters, default to 1
    current_question_index = int(request.GET.get('question', 1))

    # Ensure the index is valid
    if current_question_index < 1:
        current_question_index = 1
    elif current_question_index > questions.count():
        current_question_index = questions.count()

    # Get the current question
    try:
        current_question = questions[current_question_index - 1]
    except IndexError:
        current_question = None

    # Calculate progress percentage
    progress_percentage = 0
    if questions.count() > 0:
        progress_percentage = (current_question_index / questions.count()) * 100

    return render(request, 'surveys/survey_preview.html', {
        'questionnaire': questionnaire,
        'questions': questions,
        'current_question': current_question,
        'current_question_index': current_question_index,
        'total_questions': questions.count(),
        'progress_percentage': progress_percentage,
        'next_question_index': min(current_question_index + 1, questions.count()),
        'prev_question_index': max(current_question_index - 1, 1)
    })

@login_required
def survey_detail(request, pk):
    """
    Display questionnaire details
    """
    try:
        # Try to get the questionnaire by primary key
        # Handle the case where pk might be a string that's not a valid UUID
        try:
            # First try to convert to int if it's a numeric string
            if pk.isdigit():
                pk = int(pk)
            questionnaire = Questionnaire.objects.filter(pk=pk).first()
            if not questionnaire:
                # Try to find by slug
                questionnaire = Questionnaire.objects.filter(slug=pk).first()
                if not questionnaire:
                    # If all else fails, show an error
                    messages.error(request, f"Could not find questionnaire with ID: {pk}")
                    return redirect('surveys:survey_list')
        except (ValueError, TypeError):
            # If that fails, try to find by other fields
            try:
                # Try to find by slug
                questionnaire = Questionnaire.objects.filter(slug=pk).first()
                if not questionnaire:
                    # If all else fails, show an error
                    messages.error(request, f"Could not find questionnaire with ID: {pk}")
                    return redirect('surveys:survey_list')
            except:
                # If all else fails, show an error
                messages.error(request, f"Could not find questionnaire with ID: {pk}")
                return redirect('surveys:survey_list')

        # Check if user has permission to view this questionnaire
        try:
            # First check if the user is staff (admin)
            if request.user.is_staff:
                # Staff can view all questionnaires
                pass
            # Then check if the questionnaire has a created_by field and if the user is the creator
            elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
                # Creator can view their own questionnaires
                pass
            # Then check if the questionnaire has an organization and if the user is a member
            elif hasattr(questionnaire, 'organization') and questionnaire.organization:
                if not questionnaire.organization.members.filter(user=request.user).exists():
                    messages.error(request, "You don't have permission to view this questionnaire.")
                    return redirect('surveys:survey_list')
            # If no organization and not the creator, deny access
            else:
                messages.error(request, "You don't have permission to view this questionnaire.")
                return redirect('surveys:survey_list')
        except Exception as e:
            # If there's an error checking permissions, log it but continue
            print(f"Error checking permissions: {e}")

        questions = questionnaire.questions.all().order_by('order')

        # Get response count
        try:
            response_count = questionnaire.get_response_count()
        except Exception as e:
            # If there's an error getting the response count, log it and set to 0
            print(f"Error getting response count: {e}")
            response_count = 0

        context = {
            'questionnaire': questionnaire,
            'questions': questions,
            'response_count': response_count,
        }

        return render(request, 'surveys/survey_detail.html', context)

    except Exception as e:
        # If there's any other error, show it to the user
        messages.error(request, f"Error viewing questionnaire: {e}")
        return redirect('surveys:survey_list')

@login_required
def survey_edit(request, pk):
    """
    Edit an existing questionnaire
    """
    # Try to get the questionnaire by primary key
    # Handle the case where pk might be a string that's not a valid UUID
    try:
        # First try to convert to int if it's a numeric string
        if pk.isdigit():
            pk = int(pk)
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        # If that fails, try to find by other fields
        try:
            # Try to find by slug
            questionnaire = get_object_or_404(Questionnaire, slug=pk)
        except:
            # If all else fails, show an error
            messages.error(request, f"Could not find questionnaire with ID: {pk}")
            return redirect('surveys:survey_list')

    # Check if user has permission to edit this questionnaire
    try:
        # First check if the user is staff (admin)
        if request.user.is_staff:
            # Staff can edit all questionnaires
            pass
        # Then check if the questionnaire has a created_by field and if the user is the creator
        elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
            # Creator can edit their own questionnaires
            pass
        # Then check if the questionnaire has an organization and if the user is a member with appropriate role
        elif hasattr(questionnaire, 'organization') and questionnaire.organization:
            if not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
                messages.error(request, "You don't have permission to edit this questionnaire.")
                return redirect('surveys:survey_detail', pk=pk)
        # If no organization and not the creator, deny access
        else:
            messages.error(request, "You don't have permission to edit this questionnaire.")
            return redirect('surveys:survey_detail', pk=pk)
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking edit permissions: {e}")

    if request.method == 'POST':
        form = SurveyForm(request.POST, instance=questionnaire)
        if form.is_valid():
            try:
                form.save()
                messages.success(request, 'Questionnaire updated successfully!')
                return redirect('surveys:survey_detail', pk=pk)
            except Exception as e:
                print(f"Error updating questionnaire: {e}")
                messages.error(request, f"Error updating questionnaire: {e}")
        else:
            print(f"Form errors: {form.errors}")
    else:
        form = SurveyForm(instance=questionnaire)

    return render(request, 'surveys/survey_form.html', {
        'form': form,
        'questionnaire': questionnaire,
        'is_edit': True
    })

@login_required
def survey_delete(request, pk):
    """
    Delete a questionnaire
    """
    # Try to get the questionnaire by primary key
    # Handle the case where pk might be a string that's not a valid UUID
    try:
        # First try to convert to int if it's a numeric string
        if pk.isdigit():
            pk = int(pk)
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        # If that fails, try to find by other fields
        try:
            # Try to find by slug
            questionnaire = get_object_or_404(Questionnaire, slug=pk)
        except:
            # If all else fails, show an error
            messages.error(request, f"Could not find questionnaire with ID: {pk}")
            return redirect('surveys:survey_list')

    # Check if user has permission to delete this questionnaire
    try:
        # First check if the user is staff (admin)
        if request.user.is_staff:
            # Staff can delete all questionnaires
            pass
        # Then check if the questionnaire has a created_by field and if the user is the creator
        elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
            # Creator can delete their own questionnaires
            pass
        # Then check if the questionnaire has an organization and if the user is an admin member
        elif hasattr(questionnaire, 'organization') and questionnaire.organization:
            if not questionnaire.organization.members.filter(user=request.user, role='admin').exists():
                messages.error(request, "You don't have permission to delete this questionnaire.")
                return redirect('surveys:survey_detail', pk=pk)
        # If no organization and not the creator, deny access
        else:
            messages.error(request, "You don't have permission to delete this questionnaire.")
            return redirect('surveys:survey_detail', pk=pk)
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking delete permissions: {e}")

    if request.method == 'POST':
        questionnaire.delete()
        messages.success(request, 'Questionnaire deleted successfully!')
        return redirect('surveys:survey_list')

    return render(request, 'surveys/survey_confirm_delete.html', {'questionnaire': questionnaire})

@login_required
def survey_archive(request, pk):
    """
    Archive a questionnaire
    """
    # Try to get the questionnaire by primary key
    # Handle the case where pk might be a string that's not a valid UUID
    try:
        # First try to convert to int if it's a numeric string
        if pk.isdigit():
            pk = int(pk)
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        # If that fails, try to find by other fields
        try:
            # Try to find by slug
            questionnaire = get_object_or_404(Questionnaire, slug=pk)
        except:
            # If all else fails, show an error
            messages.error(request, f"Could not find questionnaire with ID: {pk}")
            return redirect('surveys:survey_list')

    # Check if user has permission to archive this questionnaire
    try:
        # First check if the user is staff (admin)
        if request.user.is_staff:
            # Staff can archive all questionnaires
            pass
        # Then check if the questionnaire has a created_by field and if the user is the creator
        elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
            # Creator can archive their own questionnaires
            pass
        # Then check if the questionnaire has an organization and if the user is an admin/manager member
        elif hasattr(questionnaire, 'organization') and questionnaire.organization:
            if not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
                messages.error(request, "You don't have permission to archive this questionnaire.")
                return redirect('surveys:survey_detail', pk=pk)
        # If no organization and not the creator, deny access
        else:
            messages.error(request, "You don't have permission to archive this questionnaire.")
            return redirect('surveys:survey_detail', pk=pk)
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking archive permissions: {e}")

    if request.method == 'POST':
        questionnaire.status = 'archived'
        questionnaire.save()
        messages.success(request, 'Questionnaire archived successfully!')
        return redirect('surveys:survey_list')

    return render(request, 'surveys/survey_confirm_archive.html', {'questionnaire': questionnaire})

@login_required
def survey_restore(request, pk):
    """
    Restore an archived questionnaire
    """
    # Try to get the questionnaire by primary key
    # Handle the case where pk might be a string that's not a valid UUID
    try:
        # First try to convert to int if it's a numeric string
        if pk.isdigit():
            pk = int(pk)
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        # If that fails, try to find by other fields
        try:
            # Try to find by slug
            questionnaire = get_object_or_404(Questionnaire, slug=pk)
        except:
            # If all else fails, show an error
            messages.error(request, f"Could not find questionnaire with ID: {pk}")
            return redirect('surveys:survey_list')

    # Check if user has permission to restore this questionnaire
    try:
        # First check if the user is staff (admin)
        if request.user.is_staff:
            # Staff can restore all questionnaires
            pass
        # Then check if the questionnaire has a created_by field and if the user is the creator
        elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
            # Creator can restore their own questionnaires
            pass
        # Then check if the questionnaire has an organization and if the user is a member with appropriate role
        elif hasattr(questionnaire, 'organization') and questionnaire.organization:
            if not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
                messages.error(request, "You don't have permission to restore this questionnaire.")
                return redirect('surveys:survey_detail', pk=pk)
        # If no organization and not the creator, deny access
        else:
            messages.error(request, "You don't have permission to restore this questionnaire.")
            return redirect('surveys:survey_detail', pk=pk)
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking restore permissions: {e}")

    if request.method == 'POST':
        questionnaire.status = 'draft'
        questionnaire.save()
        messages.success(request, 'Questionnaire restored successfully!')
        return redirect('surveys:survey_detail', pk=pk)

    return redirect('surveys:survey_archive_list')

@login_required
def survey_archive_list(request):
    """
    Display a list of archived questionnaires
    """
    try:
        # Try to get archived questionnaires created by the user if the field exists
        user_questionnaires = Questionnaire.objects.filter(created_by=request.user, status='archived')

        # Get archived questionnaires from organizations the user is a member of
        org_questionnaires = Questionnaire.objects.filter(organization__members__user=request.user, status='archived')

        # Combine and remove duplicates
        archived_surveys = (user_questionnaires | org_questionnaires).distinct()
    except Exception as e:
        # If 'created_by' field doesn't exist, just get questionnaires from organizations
        print(f"Error filtering by created_by in archive list: {e}")
        archived_surveys = Questionnaire.objects.filter(organization__members__user=request.user, status='archived')

    # Filter by category if provided
    category = request.GET.get('category')
    if category:
        archived_surveys = archived_surveys.filter(category=category)

    # Sort by different criteria
    sort = request.GET.get('sort', 'recent')
    if sort == 'title':
        archived_surveys = archived_surveys.order_by('title')
    elif sort == 'oldest':
        try:
            archived_surveys = archived_surveys.order_by('updated_at')
        except Exception as e:
            print(f"Error sorting by updated_at: {e}")
            # Fallback to title if updated_at doesn't exist
            archived_surveys = archived_surveys.order_by('title')
    else:  # recent
        try:
            archived_surveys = archived_surveys.order_by('-updated_at')
        except Exception as e:
            print(f"Error sorting by -updated_at: {e}")
            # Fallback to title if updated_at doesn't exist
            archived_surveys = archived_surveys.order_by('title')

    # Search functionality
    search = request.GET.get('search')
    if search:
        archived_surveys = archived_surveys.filter(
            models.Q(title__icontains=search) |
            models.Q(description__icontains=search)
        )

    # Get category choices for the filter dropdown
    try:
        category_choices = Questionnaire.CATEGORY_CHOICES
    except AttributeError:
        # Fallback categories
        category_choices = [
            ('anxiety', 'Anxiety'),
            ('depression', 'Depression'),
            ('stress', 'Stress'),
            ('general', 'General'),
            ('mental_health', 'Mental Health'),
            ('physical_health', 'Physical Health'),
            ('education', 'Education'),
            ('customer_satisfaction', 'Customer Satisfaction'),
            ('employee_feedback', 'Employee Feedback'),
            ('research', 'Research'),
            ('clinical_assessment', 'Clinical Assessment'),
            ('custom', 'Custom'),
        ]

    context = {
        'archived_surveys': archived_surveys,
        'category_choices': category_choices,
    }

    return render(request, 'surveys/survey_archive.html', context)

@login_required
def question_list(request, pk):
    """
    Display a list of questions for a questionnaire
    """
    # Add extra validation for pk
    if not pk:
        messages.error(request, "Invalid questionnaire ID.")
        return redirect('surveys:survey_list')

    try:
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        messages.error(request, "Invalid questionnaire ID format.")
        return redirect('surveys:survey_list')

    # Log the questionnaire for debugging
    logger.info(f"Viewing questions for questionnaire: {questionnaire.id}, title: {questionnaire.title}")

    # Check if user has permission to view this questionnaire's questions
    try:
        # First check if the user is staff (admin)
        if request.user.is_staff:
            # Staff can view all questionnaires' questions
            pass
        # Then check if the questionnaire has a created_by field and if the user is the creator
        elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
            # Creator can view their own questionnaires' questions
            pass
        # Then check if the questionnaire has an organization and if the user is a member
        elif hasattr(questionnaire, 'organization') and questionnaire.organization:
            if not questionnaire.organization.members.filter(user=request.user).exists():
                messages.error(request, "You don't have permission to view this questionnaire's questions.")
                return redirect('surveys:survey_list')
        # If no organization and not the creator, deny access
        else:
            messages.error(request, "You don't have permission to view this questionnaire's questions.")
            return redirect('surveys:survey_list')
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking question list permissions: {e}")

    # Get all questions for this questionnaire
    questions = questionnaire.questions.all().order_by('order')

    # Log the questions for debugging
    logger.info(f"Found {questions.count()} questions for questionnaire {questionnaire.id}")
    for q in questions:
        logger.info(f"Question ID: {q.id}, Text: {q.text}, Type: {q.question_type}")

        # For choice questions, log the choices
        if q.question_type in ['single_choice', 'multiple_choice']:
            choices = q.choices.all()
            logger.info(f"  Choices: {choices.count()}")
            for c in choices:
                logger.info(f"    Choice ID: {c.id}, Text: {c.text}, Score: {c.score}")

    return render(request, 'surveys/question_list.html', {
        'questionnaire': questionnaire,
        'questions': questions
    })

@login_required
def question_create(request, survey_pk):
    """
    Create a new question for a questionnaire - simplified version for reliability
    """
    questionnaire = get_object_or_404(Questionnaire, pk=survey_pk)

    # Check if user has permission to add questions to this questionnaire
    try:
        # First check if the user is staff (admin)
        if request.user.is_staff:
            # Staff can add questions to all questionnaires
            pass
        # Then check if the questionnaire has a created_by field and if the user is the creator
        elif hasattr(questionnaire, 'created_by') and questionnaire.created_by == request.user:
            # Creator can add questions to their own questionnaires
            pass
        # Then check if the questionnaire has an organization and if the user is a member with appropriate role
        elif hasattr(questionnaire, 'organization') and questionnaire.organization:
            if not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
                messages.error(request, "You don't have permission to add questions to this questionnaire.")
                return redirect('surveys:survey_detail', pk=survey_pk)
        # If no organization and not the creator, deny access
        else:
            messages.error(request, "You don't have permission to add questions to this questionnaire.")
            return redirect('surveys:survey_detail', pk=survey_pk)
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking question create permissions: {e}")

    # Get the next order number
    next_order = questionnaire.questions.count() + 1

    if request.method == 'POST':
        # Log the raw POST data for debugging
        logger.info(f"Question creation POST data: {json.dumps(dict(request.POST))}")

        form = QuestionForm(request.POST)

        # Log form data before validation
        logger.info(f"Form data before validation: {json.dumps({field: form[field].value() for field in form.fields})}")

        if form.is_valid():
            try:
                # SIMPLIFIED APPROACH: Create the question directly
                logger.info("Using simplified question creation approach")

                # Get the cleaned data from the form
                question_data = form.cleaned_data
                question_type = question_data.get('question_type', 'text')

                logger.info(f"Creating question with type: {question_type}")

                # Try to get the QuestionType object
                try:
                    from .models import QuestionType
                    question_type_obj = QuestionType.objects.filter(code=question_type).first()
                    logger.info(f"Found QuestionType: {question_type_obj}")
                except Exception as e:
                    logger.error(f"Error getting QuestionType: {e}")
                    question_type_obj = None

                # Set default values for scoring fields based on question type
                is_scored = question_data.get('is_scored', False)
                scoring_weight = question_data.get('scoring_weight')
                max_score = question_data.get('max_score')

                # If scoring fields are not provided but question is scored, use defaults
                if is_scored:
                    if scoring_weight is None:
                        if question_type_obj and question_type_obj.is_scorable:
                            scoring_weight = question_type_obj.default_scoring_weight
                        else:
                            scoring_weight = 1.0
                        logger.info(f"Using default scoring_weight: {scoring_weight}")

                    if max_score is None:
                        if question_type_obj and question_type_obj.is_scorable:
                            max_score = question_type_obj.default_max_score
                        else:
                            max_score = 0
                        logger.info(f"Using default max_score: {max_score}")
                else:
                    # If question is not scored, use default values
                    scoring_weight = 1.0
                    max_score = 0

                # Import timezone for datetime fields
                from django.utils import timezone

                # Create the question directly
                question = Question(
                    survey=questionnaire,
                    text=question_data.get('text', ''),
                    description=question_data.get('description', ''),
                    question_type=question_type,
                    # Remove question_type_obj parameter
                    required=question_data.get('required', True),
                    order=next_order,
                    is_scored=is_scored,
                    is_visible=question_data.get('is_visible', True),
                    scoring_weight=scoring_weight,
                    max_score=max_score,
                    category=question_data.get('category'),
                    # Add created_at and updated_at fields
                    created_at=timezone.now(),
                    updated_at=timezone.now()
                )

                # Log the question data
                logger.info(f"Question data: {vars(question)}")

                # Save the question
                question.save()
                logger.info(f"Question saved with ID: {question.id}")

                # Verify the question was saved
                saved_question = Question.objects.filter(id=question.id).first()
                if not saved_question:
                    logger.error("Failed to verify question was saved")
                    raise Exception("Question could not be saved to the database")

                # For choice-based questions, handle the choices
                if question_type in ['single_choice', 'multiple_choice']:
                    choice_texts = request.POST.getlist('choice_text')
                    choice_scores = request.POST.getlist('choice_score')

                    logger.info(f"Processing {len(choice_texts)} choices")

                    # Filter out empty choices
                    valid_choices = [(text, score) for text, score in zip(choice_texts, choice_scores) if text.strip()]

                    # If no valid choices, create default ones
                    if not valid_choices:
                        valid_choices = [("Option 1", "0"), ("Option 2", "0")]
                        logger.info("Using default choices")

                    # Create the choices
                    for i, (text, score) in enumerate(valid_choices):
                        try:
                            score_value = float(score) if score else 0
                        except ValueError:
                            score_value = 0

                        QuestionChoice.objects.create(
                            question=question,
                            text=text,
                            order=i+1,
                            score=score_value
                        )
                        logger.info(f"Created choice {i+1}: {text}")

                messages.success(request, 'Question added successfully!')
                return redirect('surveys:question_list', pk=survey_pk)

            except Exception as e:
                # Log any exceptions
                logger.error(f"Error creating question: {str(e)}")
                messages.error(request, f"Error creating question: {str(e)}")
        else:
            # Log form validation errors
            logger.error(f"Form validation failed: {form.errors}")
            messages.error(request, "Please correct the errors in the form.")
    else:
        form = QuestionForm(initial={'order': next_order})

    # Add debug information to the context
    context = {
        'form': form,
        'questionnaire': questionnaire,
    }

    # Add debug info in development
    if settings.DEBUG:
        post_data = None
        if request.method == 'POST':
            post_data = dict(request.POST)
            if 'csrfmiddlewaretoken' in post_data:
                post_data['csrfmiddlewaretoken'] = '[REDACTED]'

        context['debug_info'] = {
            'form_data': {field: form[field].value() for field in form.fields},
            'form_errors': form.errors if hasattr(form, 'errors') else None,
            'post_data': post_data,
            'question_type_choices': [choice[0] for choice in Question.TYPE_CHOICES],
        }

    return render(request, 'surveys/question_form.html', context)

@login_required
def question_detail(request, survey_pk, pk):
    """
    Display question details
    """
    questionnaire = get_object_or_404(Questionnaire, pk=survey_pk)
    question = get_object_or_404(Question, pk=pk, survey=questionnaire)

    # Check if user has permission to view this question
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user).exists():
        messages.error(request, "You don't have permission to view this question.")
        return redirect('surveys:survey_list')

    choices = question.choices.all().order_by('order')

    return render(request, 'surveys/question_detail.html', {
        'questionnaire': questionnaire,
        'question': question,
        'choices': choices
    })

@login_required
def question_edit(request, survey_pk, pk):
    """
    Edit an existing question
    """
    questionnaire = get_object_or_404(Questionnaire, pk=survey_pk)
    question = get_object_or_404(Question, pk=pk, survey=questionnaire)

    # Check if user has permission to edit this question
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
        messages.error(request, "You don't have permission to edit this question.")
        return redirect('surveys:question_detail', survey_pk=survey_pk, pk=pk)

    if request.method == 'POST':
        form = QuestionForm(request.POST, instance=question)

        if form.is_valid():
            # Get the question instance but don't save it yet
            question_instance = form.save(commit=False)

            # Ensure question_type is explicitly set from the form
            question_instance.question_type = form.cleaned_data.get('question_type', 'text')

            # Save the question with the updated question_type
            question_instance.save()

            # Log the question update for debugging
            print(f"Question updated with type: {question_instance.question_type}")

            # Handle choices for multiple choice questions
            if question.question_type in ['single_choice', 'multiple_choice']:
                # First, delete existing choices
                question.choices.all().delete()

                # Then create new ones
                choice_texts = request.POST.getlist('choice_text')
                choice_scores = request.POST.getlist('choice_score')

                for i, (text, score) in enumerate(zip(choice_texts, choice_scores)):
                    if text:  # Only create choices with text
                        try:
                            score_value = float(score) if score else 0
                        except ValueError:
                            score_value = 0

                        QuestionChoice.objects.create(
                            question=question,
                            text=text,
                            order=i+1,
                            score=score_value
                        )

            messages.success(request, 'Question updated successfully!')
            return redirect('surveys:question_detail', survey_pk=survey_pk, pk=pk)
    else:
        form = QuestionForm(instance=question)

    choices = question.choices.all().order_by('order')

    return render(request, 'surveys/question_form.html', {
        'form': form,
        'questionnaire': questionnaire,
        'question': question,
        'choices': choices,
        'is_edit': True
    })

@login_required
def question_delete(request, survey_pk, pk):
    """
    Delete a question
    """
    questionnaire = get_object_or_404(Questionnaire, pk=survey_pk)
    question = get_object_or_404(Question, pk=pk, survey=questionnaire)

    # Check if user has permission to delete this question
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
        messages.error(request, "You don't have permission to delete this question.")
        return redirect('surveys:question_detail', survey_pk=survey_pk, pk=pk)

    if request.method == 'POST':
        # Delete the question
        question.delete()

        # Reorder remaining questions
        for i, q in enumerate(questionnaire.questions.all().order_by('order')):
            q.order = i + 1
            q.save()

        messages.success(request, 'Question deleted successfully!')
        return redirect('surveys:question_list', pk=survey_pk)

    return render(request, 'surveys/question_confirm_delete.html', {
        'questionnaire': questionnaire,
        'question': question
    })

@login_required
def generate_qr_code(request, pk):
    """
    Generate a QR code for a questionnaire
    """
    # Try to get the questionnaire by primary key
    # Handle the case where pk might be a string that's not a valid UUID
    try:
        # First try to convert to int if it's a numeric string
        if pk.isdigit():
            pk = int(pk)
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    except (ValueError, TypeError):
        # If that fails, try to find by other fields
        try:
            # Try to find by slug
            questionnaire = get_object_or_404(Questionnaire, slug=pk)
        except:
            # If all else fails, show an error
            messages.error(request, f"Could not find questionnaire with ID: {pk}")
            return redirect('surveys:survey_list')

    download = request.GET.get('download') == 'true'

    # Check if user has permission to view this questionnaire
    try:
        if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user).exists():
            messages.error(request, "You don't have permission to view this questionnaire's QR code.")
            return redirect('surveys:survey_list')
    except Exception as e:
        # If there's an error checking permissions, log it but continue
        print(f"Error checking permissions for QR code: {e}")

    # If questionnaire already has a QR code and we're not downloading it, use the template
    try:
        if questionnaire.qr_code and not download:
            return render(request, 'surveys/qr_code.html', {'survey': questionnaire})
    except Exception as e:
        # If there's an error checking the QR code, log it and continue
        print(f"Error checking QR code: {e}")

    # Generate a new QR code
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )

    # Use the direct questionnaire access URL
    questionnaire_url = request.build_absolute_uri(f"/q/{questionnaire.pk}/")
    qr.add_data(questionnaire_url)
    qr.make(fit=True)

    img = qr.make_image(fill_color="black", back_color="white")

    # Save the QR code to the questionnaire if it doesn't exist
    if not questionnaire.qr_code:
        buffer = BytesIO()
        img.save(buffer, format="PNG")
        buffer.seek(0)
        questionnaire.qr_code.save(f"qr_{questionnaire.slug}.png", File(buffer), save=True)

    # If download parameter is provided, return the image as a download
    if download:
        response = HttpResponse(content_type="image/png")
        response['Content-Disposition'] = f'attachment; filename="qr_code_{questionnaire.slug}.png"'
        img.save(response, "PNG")
        return response

    # For direct image access (when used in img src), return the image directly
    if 'raw' in request.GET:
        response = HttpResponse(content_type="image/png")
        img.save(response, "PNG")
        return response

    # Otherwise, render the template
    return render(request, 'surveys/qr_code.html', {'survey': questionnaire})


def survey_respond(request, slug=None, pk=None):
    """
    Public view for responding to a questionnaire via QR code or direct link
    Can be accessed by slug or pk
    """
    # Get the questionnaire by slug or pk
    if slug:
        questionnaire = get_object_or_404(Questionnaire, slug=slug)
    elif pk:
        questionnaire = get_object_or_404(Questionnaire, pk=pk)
    else:
        messages.error(request, "Invalid questionnaire link.")
        return redirect('core:home')

    # Check if questionnaire is active
    if questionnaire.status != 'active':
        messages.error(request, "This questionnaire is not currently active.")
        return redirect('core:home')

    # If the questionnaire requires authentication, check if user is logged in
    if questionnaire.requires_auth and not request.user.is_authenticated:
        messages.info(request, "Please log in to access this questionnaire.")
        return redirect('account_login')

    # Track QR code access if accessed via QR code
    qr_code_id = request.GET.get('qr')
    if qr_code_id:
        try:
            qr_code = questionnaire.qr_codes.get(pk=qr_code_id, is_active=True)
            qr_code.increment_access_count()
        except:
            # If QR code doesn't exist or isn't active, just continue
            pass

    # Get all questions for this questionnaire
    questions = questionnaire.questions.all().order_by('order')

    # Get the current question index from the query parameters, default to 1
    current_question_index = int(request.GET.get('question', 1))

    # Ensure the index is valid
    if current_question_index < 1:
        current_question_index = 1
    elif current_question_index > questions.count():
        current_question_index = questions.count()

    # Get the current question
    try:
        current_question = questions[current_question_index - 1]
    except IndexError:
        current_question = None

    # Calculate progress percentage
    progress_percentage = 0
    if questions.count() > 0:
        progress_percentage = (current_question_index / questions.count()) * 100

    return render(request, 'surveys/survey_respond.html', {
        'questionnaire': questionnaire,
        'questions': questions,
        'current_question': current_question,
        'current_question_index': current_question_index,
        'total_questions': questions.count(),
        'progress_percentage': progress_percentage,
        'next_question_index': min(current_question_index + 1, questions.count()),
        'prev_question_index': max(current_question_index - 1, 1)
    })


@login_required
def scoring_config_list(request, questionnaire_pk):
    """
    Display a list of scoring configurations for a questionnaire
    """
    questionnaire = get_object_or_404(Questionnaire, pk=questionnaire_pk)

    # Check if user has permission to view this questionnaire's scoring configs
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user).exists():
        messages.error(request, "You don't have permission to view this questionnaire's scoring configurations.")
        return redirect('surveys:survey_list')

    scoring_configs = questionnaire.scoring_configs.all().order_by('-created_at')

    return render(request, 'surveys/scoring_config_list.html', {
        'questionnaire': questionnaire,
        'scoring_configs': scoring_configs
    })

@login_required
def scoring_config_create(request, questionnaire_pk):
    """
    Create a new scoring configuration for a questionnaire
    """
    questionnaire = get_object_or_404(Questionnaire, pk=questionnaire_pk)

    # Check if user has permission to add scoring configs to this questionnaire
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
        messages.error(request, "You don't have permission to add scoring configurations to this questionnaire.")
        return redirect('surveys:survey_detail', pk=questionnaire_pk)

    if request.method == 'POST':
        form = ScoringConfigForm(request.POST, questionnaire=questionnaire)
        if form.is_valid():
            scoring_config = form.save(commit=False)
            scoring_config.survey = questionnaire
            scoring_config.created_by = request.user
            scoring_config.save()
            messages.success(request, 'Scoring configuration created successfully!')
            return redirect('surveys:scoring_config_detail', questionnaire_pk=questionnaire_pk, pk=scoring_config.pk)
    else:
        form = ScoringConfigForm(questionnaire=questionnaire)

    return render(request, 'surveys/scoring_config_form.html', {
        'form': form,
        'questionnaire': questionnaire,
        'is_create': True
    })

@login_required
def scoring_config_detail(request, questionnaire_pk, pk):
    """
    Display scoring configuration details
    """
    questionnaire = get_object_or_404(Questionnaire, pk=questionnaire_pk)
    scoring_config = get_object_or_404(ScoringConfig, pk=pk, survey=questionnaire)

    # Check if user has permission to view this scoring config
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user).exists():
        messages.error(request, "You don't have permission to view this scoring configuration.")
        return redirect('surveys:survey_list')

    return render(request, 'surveys/scoring_config_detail.html', {
        'questionnaire': questionnaire,
        'scoring_config': scoring_config
    })

@login_required
def scoring_config_edit(request, questionnaire_pk, pk):
    """
    Edit an existing scoring configuration
    """
    questionnaire = get_object_or_404(Questionnaire, pk=questionnaire_pk)
    scoring_config = get_object_or_404(ScoringConfig, pk=pk, survey=questionnaire)

    # Check if user has permission to edit this scoring config
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
        messages.error(request, "You don't have permission to edit this scoring configuration.")
        return redirect('surveys:scoring_config_detail', questionnaire_pk=questionnaire_pk, pk=pk)

    if request.method == 'POST':
        form = ScoringConfigForm(request.POST, instance=scoring_config, questionnaire=questionnaire)
        if form.is_valid():
            form.save()
            messages.success(request, 'Scoring configuration updated successfully!')
            return redirect('surveys:scoring_config_detail', questionnaire_pk=questionnaire_pk, pk=pk)
    else:
        form = ScoringConfigForm(instance=scoring_config, questionnaire=questionnaire)

    return render(request, 'surveys/scoring_config_form.html', {
        'form': form,
        'questionnaire': questionnaire,
        'scoring_config': scoring_config,
        'is_edit': True
    })

@login_required
def scoring_config_delete(request, questionnaire_pk, pk):
    """
    Delete a scoring configuration
    """
    questionnaire = get_object_or_404(Questionnaire, pk=questionnaire_pk)
    scoring_config = get_object_or_404(ScoringConfig, pk=pk, survey=questionnaire)

    # Check if user has permission to delete this scoring config
    if questionnaire.created_by != request.user and not questionnaire.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists():
        messages.error(request, "You don't have permission to delete this scoring configuration.")
        return redirect('surveys:scoring_config_detail', questionnaire_pk=questionnaire_pk, pk=pk)

    if request.method == 'POST':
        scoring_config.delete()
        messages.success(request, 'Scoring configuration deleted successfully!')
        return redirect('surveys:scoring_config_list', questionnaire_pk=questionnaire_pk)

    return render(request, 'surveys/scoring_config_confirm_delete.html', {
        'questionnaire': questionnaire,
        'scoring_config': scoring_config
    })

@login_required
def email_template_list(request):
    """
    Display a list of email templates
    """
    # Get templates created by the user or in their organizations
    user_templates = EmailTemplate.objects.filter(created_by=request.user)

    # Get templates from organizations the user is a member of
    org_templates = EmailTemplate.objects.filter(organization__members__user=request.user)

    # Combine and remove duplicates
    templates = (user_templates | org_templates).distinct().order_by('-created_at')

    return render(request, 'surveys/email_template_list.html', {
        'templates': templates
    })

@login_required
def email_template_create(request):
    """
    Create a new email template
    """
    if request.method == 'POST':
        form = EmailTemplateForm(request.POST)
        if form.is_valid():
            template = form.save(commit=False)
            template.created_by = request.user
            template.save()
            messages.success(request, 'Email template created successfully!')
            return redirect('surveys:email_template_detail', pk=template.pk)
    else:
        form = EmailTemplateForm()

    return render(request, 'surveys/email_template_form.html', {
        'form': form,
        'is_create': True
    })

@login_required
def email_template_detail(request, pk):
    """
    Display email template details
    """
    template = get_object_or_404(EmailTemplate, pk=pk)

    # Check if user has permission to view this template
    if template.created_by != request.user and (template.organization and not template.organization.members.filter(user=request.user).exists()):
        messages.error(request, "You don't have permission to view this email template.")
        return redirect('surveys:email_template_list')

    return render(request, 'surveys/email_template_detail.html', {
        'template': template
    })

@login_required
def email_template_edit(request, pk):
    """
    Edit an existing email template
    """
    template = get_object_or_404(EmailTemplate, pk=pk)

    # Check if user has permission to edit this template
    if template.created_by != request.user and (template.organization and not template.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists()):
        messages.error(request, "You don't have permission to edit this email template.")
        return redirect('surveys:email_template_detail', pk=pk)

    if request.method == 'POST':
        form = EmailTemplateForm(request.POST, instance=template)
        if form.is_valid():
            form.save()
            messages.success(request, 'Email template updated successfully!')
            return redirect('surveys:email_template_detail', pk=pk)
    else:
        form = EmailTemplateForm(instance=template)

    return render(request, 'surveys/email_template_form.html', {
        'form': form,
        'template': template,
        'is_edit': True
    })

@login_required
def email_template_delete(request, pk):
    """
    Delete an email template
    """
    template = get_object_or_404(EmailTemplate, pk=pk)

    # Check if user has permission to delete this template
    if template.created_by != request.user and (template.organization and not template.organization.members.filter(user=request.user, role__in=['admin', 'manager']).exists()):
        messages.error(request, "You don't have permission to delete this email template.")
        return redirect('surveys:email_template_detail', pk=pk)

    if request.method == 'POST':
        template.delete()
        messages.success(request, 'Email template deleted successfully!')
        return redirect('surveys:email_template_list')

    return render(request, 'surveys/email_template_confirm_delete.html', {
        'template': template
    })

@login_required
def survey_templates(request):
    """
    Display a list of template questionnaires
    """
    # Get template questionnaires
    try:
        # Try to get template questionnaires if the field exists
        templates = Questionnaire.objects.filter(is_template=True).order_by('-created_at')
    except Exception as e:
        # If 'is_template' field doesn't exist, use an empty queryset
        print(f"Error filtering by is_template in survey_templates: {e}")
        templates = Questionnaire.objects.none()

    # Filter by category if provided
    category = request.GET.get('category')
    if category:
        templates = templates.filter(category=category)

    # Filter by search term if provided
    search = request.GET.get('search')
    if search:
        templates = templates.filter(
            models.Q(title__icontains=search) |
            models.Q(description__icontains=search)
        )

    # Get category choices for the filter dropdown
    try:
        categories = Questionnaire.CATEGORY_CHOICES
    except AttributeError:
        # Fallback categories
        categories = [
            ('anxiety', 'Anxiety'),
            ('depression', 'Depression'),
            ('stress', 'Stress'),
            ('general', 'General'),
            ('mental_health', 'Mental Health'),
            ('physical_health', 'Physical Health'),
            ('education', 'Education'),
            ('customer_satisfaction', 'Customer Satisfaction'),
            ('employee_feedback', 'Employee Feedback'),
            ('research', 'Research'),
            ('clinical_assessment', 'Clinical Assessment'),
            ('custom', 'Custom'),
        ]

    context = {
        'templates': templates,
        'categories': categories,
    }

    return render(request, 'surveys/survey_templates.html', context)
